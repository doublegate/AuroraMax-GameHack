YAMLname: Build and Deploy AuroraMax-GameHack

on:
  schedule:
    - cron: "0 7 * * *"  # 7 AM UTC everyday
  push:
    branches:
      - main
    tags:
      - 'v*.*.*' # Trigger on version tags (e.g., v1.0.0, v1.2.3-alpha)
    paths-ignore:
      - '**/README.md'
      - 'docs/**'
  pull_request:
    branches:
      - main
    paths-ignore:
      - '**/README.md'
      - 'docs/**'
  workflow_dispatch:
    inputs:
      logLevel:
        description: 'Log level for the BlueBuild process (passed to CLI if supported, otherwise for workflow steps)'
        required: false
        default: 'info'
        type: choice
        options:
          - info
          - warning
          - debug
      imageVersionOverride:
        description: 'Optional: Specify a semantic version for the org.opencontainers.image.version OCI label (e.g., 1.2.3). Overrides Git tag derivation.'
        required: false
        type: string
      customImageTagOverride:
        description: 'Optional: Specify a custom Docker tag for the image (e.g., my-special-build). Overrides default event-based tagging.'
        required: false
        type: string

env:
  REGISTRY: ghcr.io
  IMAGE_NAMESPACE: ${{ github.repository_owner }}
  # IMAGE_NAME is derived from recipe.yml in the 'get_image_name' step.
  # OCI labels like title, description, source, revision, created are largely auto-set by BlueBuild CLI v0.9.0+ [1]

jobs:
  build_and_sign_image:
    name: Build and Sign OCI Image
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write # Required to publish images to GHCR.io
      id-token: write # For OIDC with Sigstore (if keyless) or registry

    outputs:
      IMAGE_NAME: ${{ steps.get_image_name.outputs.IMAGE_NAME }}
      FINAL_IMAGE_TAG: ${{ steps.determine_tags.outputs.FINAL_IMAGE_TAG }}
      IMAGE_DIGEST: ${{ steps.build_image.outputs.image_digest }} # Provided by blue-build/github-action
      OCI_VERSION_LABEL: ${{ steps.determine_tags.outputs.OCI_VERSION_LABEL }}
      FULL_IMAGE_REF_WITH_TAG: ${{ env.REGISTRY }}/${{ env.IMAGE_NAMESPACE }}/${{ steps.get_image_name.outputs.IMAGE_NAME }}:${{ steps.determine_tags.outputs.FINAL_IMAGE_TAG }}
      FULL_IMAGE_REF_WITH_DIGEST: ${{ env.REGISTRY }}/${{ env.IMAGE_NAMESPACE }}/${{ steps.get_image_name.outputs.IMAGE_NAME }}@${{ steps.build_image.outputs.image_digest }}

    strategy:
      fail-fast: false
      matrix:
        recipe_file:
          - recipe.yml # Assumes recipe.yml is at the root or configured path

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Fetches all history for all tags/branches, crucial for Git-based versioning

      - name: Get Image Name from Recipe
        id: get_image_name
        run: |
          IMAGE_NAME_FROM_RECIPE=$(grep -oP '^\s*name:\s*\K\S+' ${{ matrix.recipe_file }} | tr '[:upper:]' '[:lower:]' |
| echo "")
          if; then
            echo "Error: 'name' field not found or empty in ${{ matrix.recipe_file }}. It's required for image naming and OCI labels."
            exit 1
          fi
          echo "IMAGE_NAME=${IMAGE_NAME_FROM_RECIPE}" >> $GITHUB_OUTPUT
          echo "Derived image name: ${IMAGE_NAME_FROM_RECIPE}"

      - name: Determine Image Tags and OCI Version Label
        id: determine_tags
        run: |
          # OCI_VERSION_LABEL: For org.opencontainers.image.version OCI label.
          # FINAL_IMAGE_TAG: The actual Docker tag to be applied.

          OCI_VERSION_LABEL_VALUE=""
          DOCKER_TAG_VALUE=""

          # Determine OCI Version Label
          if [[ -n "${{ inputs.imageVersionOverride }}" ]]; then
            OCI_VERSION_LABEL_VALUE="${{ inputs.imageVersionOverride }}"
          elif [[ "${{ github.ref_type }}" == "tag" && "${{ github.ref_name }}" =~ ^v([0-9]+\.[0-9]+\.[0-9]+.*)$ ]]; then
            OCI_VERSION_LABEL_VALUE="${BASH_REMATCH[2]}" # Extract version part, e.g., 1.2.3 from v1.2.3
          else
            OCI_VERSION_LABEL_VALUE="${{ github.sha }}" # Fallback to full SHA
          fi

          # Determine Docker Tag
          if]; then
            DOCKER_TAG_VALUE="${{ inputs.customImageTagOverride }}"
          elif [[ "${{ github.ref_type }}" == "tag" ]]; then
            DOCKER_TAG_VALUE="${{ github.ref_name }}" # Use Git tag directly
          elif [[ "${{ github.event_name }}" == "pull_request" ]]; then
            DOCKER_TAG_VALUE="pr-${{ github.event.number }}"
          elif [[ "${{ github.ref_name }}" == "main" && "${{ github.event_name }}" == "push" ]]; then
            DOCKER_TAG_VALUE="latest"
          elif [[ "${{ github.event_name }}" == "schedule" ]]; then
            DOCKER_TAG_VALUE="nightly-$(date +'%Y%m%d')"
          elif [[ "${{ github.ref_name }}"!= "main" && "${{ github.event_name }}" == "push" ]];then
            BRANCH_NAME_TAG=$(echo "${{ github.ref_name }}" | sed 's/[^a-zA-Z0-9.-]/-/g' | sed 's/^-*//;s/-*$//' | tr '[:upper:]' '[:lower:]')
            DOCKER_TAG_VALUE="${BRANCH_NAME_TAG:-${GITHUB_SHA::8}}"
          else
            DOCKER_TAG_VALUE="${GITHUB_SHA::8}" # Fallback to short SHA
          fi

          echo "OCI_VERSION_LABEL=${OCI_VERSION_LABEL_VALUE}" >> $GITHUB_OUTPUT
          echo "FINAL_IMAGE_TAG=${DOCKER_TAG_VALUE}" >> $GITHUB_OUTPUT
          echo "Determined OCI Version Label: ${OCI_VERSION_LABEL_VALUE}"
          echo "Determined Final Image Tag: ${DOCKER_TAG_VALUE}"

      - name: Build Custom Image with BlueBuild
        id: build_image
        uses: blue-build/github-action@v1.8.1
        # This step builds the OCI image using the specified recipe, signs it with Cosign,
        # and pushes it to the configured container registry (GHCR.io in this setup).
        # The action handles the push using the provided registry_token and 'packages: write' permission.
        with:
          recipe: ${{ matrix.recipe_file }}
          cosign_private_key: ${{ secrets.COSIGN_PRIVATE_KEY }}
          cosign_password: ${{ secrets.COSIGN_PASSWORD }}
          registry_token: ${{ secrets.GITHUB_TOKEN }}
          pr_event_number: ${{ github.event.pull_request.number }} # Used by action for PR image tagging
          registry: ${{ env.REGISTRY }}
          registry_namespace: ${{ env.IMAGE_NAMESPACE }}
          # The blue-build/github-action internally handles tagging.
          # For PRs, it uses pr-${pr_event_number}. For main branch, it uses 'latest' and date-based tags.
          # For Git tags, it should ideally use the Git tag. If `alt-tags` is set in recipe.yml, those will override.
          # The `FINAL_IMAGE_TAG` determined above is primarily for consistent reference in deployment
          # and for the OCI version label if passed via build_opts.
          # The actual tag applied by blue-build/github-action might vary based on its internal logic for the event.
          # To ensure the `FINAL_IMAGE_TAG` is applied, one might need to use `alt-tags` dynamically in recipe.yml (if supported)
          # or re-tag after this step. This workflow assumes the action's tagging is sufficient for most cases,
          # and `FINAL_IMAGE_TAG` is for clear reference and potential OCI versioning.
          build_opts: |
            --build-arg IMAGE_VERSION_ARG=${{ steps.determine_tags.outputs.OCI_VERSION_LABEL }}
            --build-arg GIT_SHA_ARG=${{ github.sha }}
            --build-arg SOURCE_REPO_URL_ARG=${{ github.server_url }}/${{ github.repository }}
            --build-arg IMAGE_NAME_ARG=${{ steps.get_image_name.outputs.IMAGE_NAME }}
            --build-arg IMAGE_TAG_ARG=${{ steps.determine_tags.outputs.FINAL_IMAGE_TAG }}

  deploy_content:
    name: Deploy Project Content
    runs-on: ubuntu-latest
    needs: build_and_sign_image
    if: github.event_name == 'push' && (github.ref == 'refs/heads/main' |
| startsWith(github.ref, 'refs/tags/v'))

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Display Built Image Information for Deployment
        env:
          IMAGE_NAME: ${{ needs.build_and_sign_image.outputs.IMAGE_NAME }}
          IMAGE_TAG: ${{ needs.build_and_sign_image.outputs.FINAL_IMAGE_TAG }} # Use the tag determined by our logic
          IMAGE_DIGEST: ${{ needs.build_and_sign_image.outputs.IMAGE_DIGEST }}
          OCI_VERSION: ${{ needs.build_and_sign_image.outputs.OCI_VERSION_LABEL }}
          FULL_IMAGE_REF_TAG: ${{ needs.build_and_sign_image.outputs.FULL_IMAGE_REF_WITH_TAG }}
          FULL_IMAGE_REF_DIGEST: ${{ needs.build_and_sign_image.outputs.FULL_IMAGE_REF_WITH_DIGEST }}
        run: |
          echo "Deployment Details for AuroraMax-GameHack:"
          echo "--------------------------------------------------"
          echo "Image Name: ${IMAGE_NAME}"
          echo "Image Tag: ${IMAGE_TAG}"
          echo "Image Digest: ${IMAGE_DIGEST}"
          echo "OCI Version Label Value: ${OCI_VERSION}"
          echo "--------------------------------------------------"
          echo "Image was published to GHCR.io during the 'build_and_sign_image' job."
          echo "Deploying from (tag-based): ${FULL_IMAGE_REF_TAG}"
          echo "Deploying from (digest-based, recommended for immutability): ${FULL_IMAGE_REF_DIGEST}"
          echo "--------------------------------------------------"

      - name: Placeholder for Actual Deployment Steps
        env:
          # Example secrets - configure these in your repository settings
          # DEPLOYMENT_SERVER: ${{ secrets.DEPLOY_SERVER_ADDRESS }}
          # DEPLOYMENT_USER: ${{ secrets.DEPLOY_SERVER_USER }}
          # SSH_PRIVATE_KEY: ${{ secrets.DEPLOY_SSH_PRIVATE_KEY }}
          # KUBECONFIG_DATA: ${{ secrets.KUBECONFIG_STAGING }}
          IMAGE_TO_DEPLOY_WITH_DIGEST: ${{ needs.build_and_sign_image.outputs.FULL_IMAGE_REF_WITH_DIGEST }}
        run: |
          echo "INFO: This section contains placeholder deployment steps."
          echo "You MUST replace these with commands specific to your AuroraMax-GameHack project and target environment."
          echo ""
          echo "The custom OS image has already been published to GHCR.io: ${IMAGE_TO_DEPLOY_WITH_DIGEST}"
          echo "The steps below should focus on USING this published image or deploying other project assets."
          echo ""
          echo "Common Deployment Scenarios & Examples:"
          echo "----------------------------------------"
          echo "1. Deploying to a Kubernetes Cluster (using the image from GHCR.io):"
          echo "   # Ensure kubectl is configured (e.g., using KUBECONFIG_DATA secret)"
          echo "   # echo \"${KUBECONFIG_DATA}\" >./kubeconfig.yaml"
          echo "   # export KUBECONFIG=./kubeconfig.yaml"
          echo "   # kubectl set image deployment/auroramax-deployment gamehack-container=${IMAGE_TO_DEPLOY_WITH_DIGEST} --namespace your-namespace --record"
          echo ""
          echo "2. Deploying to a Docker Host via SSH (pulling the image from GHCR.io):"
          echo "   # Ensure SSH agent is configured with your private key"
          echo "   # ssh -o StrictHostKeyChecking=no ${DEPLOYMENT_USER}@${DEPLOYMENT_SERVER} \\"
          echo "   #   \"docker pull ${IMAGE_TO_DEPLOY_WITH_DIGEST} && \\"
          echo "   #    docker stop auroramax_container |
| true && \\"
          echo "   #    docker rm auroramax_container |
| true && \\"
          echo "   #    docker run -d --name auroramax_container ${IMAGE_TO_DEPLOY_WITH_DIGEST}\""
          echo ""
          echo "3. Publishing Game Assets (if not part of the OCI image):"
          echo "   # Example: Syncing an 'assets' directory to an S3 bucket"
          echo "   # aws s3 sync./dist/game_assets s3://your-auroramax-assets-bucket/ --delete"
          echo ""
          echo "4. Updating a GitHub Pages site (if your project includes web content):"
          echo "   # - name: Build and Deploy GitHub Pages"
          echo "   #   uses: actions/deploy-pages@vX # Replace vX with the latest version"
          echo "   #   # Ensure your GitHub Pages settings are configured in the repository"
          echo "   #   # And that the build job produces artifacts in the expected location for this action."
          echo ""
          echo "IMPORTANT: Configure all necessary secrets (e.g., cloud provider credentials, SSH keys, API tokens)"
          echo "in your GitHub repository settings under 'Secrets and variables > Actions'."
          echo "----------------------------------------"
          echo "Placeholder deployment finished."
